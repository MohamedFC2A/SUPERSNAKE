-- SUPERSNAKE â€” Supabase SQL (schema + RLS + seed template)
-- Run this in Supabase Dashboard -> SQL Editor.

-- 1) Tables
create table if not exists public.profiles (
  id uuid not null references auth.users (id) on delete cascade,
  username text,
  avatar_url text,
  theme text not null default 'dark' check (theme in ('dark','light')),
  settings jsonb not null default '{}'::jsonb,
  updated_at timestamptz not null default now(),
  primary key (id)
);

-- Migration-safe: add column if upgrading an existing project
alter table public.profiles add column if not exists settings jsonb not null default '{}'::jsonb;

create table if not exists public.scores (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  username text,
  score integer not null check (score >= 0),
  created_at timestamptz not null default now()
);

create index if not exists scores_user_id_idx on public.scores (user_id);
create index if not exists scores_score_idx on public.scores (score desc);
create index if not exists scores_created_at_idx on public.scores (created_at desc);

-- Per-game sessions (used to compute profile statistics)
create table if not exists public.game_sessions (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  score integer not null check (score >= 0),
  survival_ms integer not null check (survival_ms >= 0),
  created_at timestamptz not null default now()
);

create index if not exists game_sessions_user_id_idx on public.game_sessions (user_id);
create index if not exists game_sessions_created_at_idx on public.game_sessions (created_at desc);

-- Aggregated user stats (maintained by trigger)
create table if not exists public.user_stats (
  user_id uuid primary key references auth.users (id) on delete cascade,
  games_played integer not null default 0,
  total_score bigint not null default 0,
  best_score integer not null default 0,
  longest_survival_ms integer not null default 0,
  updated_at timestamptz not null default now()
);

-- Online changelog (public read, admin write)
create table if not exists public.admins (
  user_id uuid primary key references auth.users (id) on delete cascade,
  created_at timestamptz not null default now()
);

-- Migration-safe: add columns if upgrading an existing project
alter table public.admins add column if not exists created_at timestamptz not null default now();

create table if not exists public.changelog_entries (
  id bigint generated by default as identity primary key,
  version text not null,
  title text not null,
  date date not null default current_date,
  description text not null default '',
  added jsonb,
  changed jsonb,
  fixed jsonb,
  locale text default null check (locale in ('en','ar') or locale is null),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Migration-safe: add columns if upgrading an existing project
alter table public.changelog_entries add column if not exists version text;
alter table public.changelog_entries add column if not exists title text;
alter table public.changelog_entries add column if not exists date date;
alter table public.changelog_entries add column if not exists description text not null default '';
alter table public.changelog_entries add column if not exists added jsonb;
alter table public.changelog_entries add column if not exists changed jsonb;
alter table public.changelog_entries add column if not exists fixed jsonb;
alter table public.changelog_entries add column if not exists locale text;
alter table public.changelog_entries add column if not exists created_at timestamptz not null default now();
alter table public.changelog_entries add column if not exists updated_at timestamptz not null default now();

-- Backfill + constraints for the date column (handles projects where the table existed without it)
update public.changelog_entries set date = current_date where date is null;
alter table public.changelog_entries alter column date set default current_date;
alter table public.changelog_entries alter column date set not null;

create index if not exists changelog_entries_date_idx on public.changelog_entries (date desc);
create index if not exists changelog_entries_locale_idx on public.changelog_entries (locale);

-- 2) Triggers
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists profiles_set_updated_at on public.profiles;
create trigger profiles_set_updated_at
before update on public.profiles
for each row execute function public.set_updated_at();

drop trigger if exists changelog_entries_set_updated_at on public.changelog_entries;
create trigger changelog_entries_set_updated_at
before update on public.changelog_entries
for each row execute function public.set_updated_at();

-- Auto-create a profile row for each new auth user (optional but recommended)
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles (id, username, avatar_url)
  values (
    new.id,
    coalesce(
      new.raw_user_meta_data->>'full_name',
      new.raw_user_meta_data->>'name',
      case when new.email is null then null else split_part(new.email, '@', 1) end
    ),
    new.raw_user_meta_data->>'avatar_url'
  )
  on conflict (id) do nothing;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute function public.handle_new_user();

-- Maintain aggregated stats when a session is inserted.
create or replace function public.apply_session_to_user_stats()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.user_stats (user_id, games_played, total_score, best_score, longest_survival_ms, updated_at)
  values (new.user_id, 1, new.score, new.score, new.survival_ms, now())
  on conflict (user_id) do update set
    games_played = public.user_stats.games_played + 1,
    total_score = public.user_stats.total_score + new.score,
    best_score = greatest(public.user_stats.best_score, new.score),
    longest_survival_ms = greatest(public.user_stats.longest_survival_ms, new.survival_ms),
    updated_at = now();
  return new;
end;
$$;

drop trigger if exists on_game_session_insert on public.game_sessions;
create trigger on_game_session_insert
after insert on public.game_sessions
for each row execute function public.apply_session_to_user_stats();

-- 3) Row Level Security (RLS)
alter table public.profiles enable row level security;
alter table public.scores enable row level security;
alter table public.game_sessions enable row level security;
alter table public.user_stats enable row level security;
alter table public.admins enable row level security;
alter table public.changelog_entries enable row level security;

-- Public read (so leaderboards work without login too)
-- Profiles contain private settings; only the owner can read their row.
drop policy if exists "profiles_select_public" on public.profiles;
drop policy if exists "profiles_select_own" on public.profiles;
create policy "profiles_select_own"
on public.profiles
for select
using (auth.uid() = id);

drop policy if exists "scores_select_public" on public.scores;
create policy "scores_select_public"
on public.scores
for select
using (true);

-- Changelog entries are public read
drop policy if exists "changelog_select_public" on public.changelog_entries;
create policy "changelog_select_public"
on public.changelog_entries
for select
using (true);

-- Admin membership: allow authenticated users to check if they are in the admins table
drop policy if exists "admins_select_own" on public.admins;
create policy "admins_select_own"
on public.admins
for select
using (auth.uid() = user_id);

-- Only admins can write changelog entries
drop policy if exists "changelog_insert_admin" on public.changelog_entries;
create policy "changelog_insert_admin"
on public.changelog_entries
for insert
with check (exists (select 1 from public.admins a where a.user_id = auth.uid()));

drop policy if exists "changelog_update_admin" on public.changelog_entries;
create policy "changelog_update_admin"
on public.changelog_entries
for update
using (exists (select 1 from public.admins a where a.user_id = auth.uid()))
with check (exists (select 1 from public.admins a where a.user_id = auth.uid()));

drop policy if exists "changelog_delete_admin" on public.changelog_entries;
create policy "changelog_delete_admin"
on public.changelog_entries
for delete
using (exists (select 1 from public.admins a where a.user_id = auth.uid()));

-- Users can manage their own profile
drop policy if exists "profiles_insert_own" on public.profiles;
create policy "profiles_insert_own"
on public.profiles
for insert
with check (auth.uid() = id);

drop policy if exists "profiles_update_own" on public.profiles;
create policy "profiles_update_own"
on public.profiles
for update
using (auth.uid() = id)
with check (auth.uid() = id);

-- Users can submit only their own scores
drop policy if exists "scores_insert_own" on public.scores;
create policy "scores_insert_own"
on public.scores
for insert
with check (auth.uid() = user_id);

-- Game sessions: users insert/select only their own
drop policy if exists "game_sessions_select_own" on public.game_sessions;
create policy "game_sessions_select_own"
on public.game_sessions
for select
using (auth.uid() = user_id);

drop policy if exists "game_sessions_insert_own" on public.game_sessions;
create policy "game_sessions_insert_own"
on public.game_sessions
for insert
with check (auth.uid() = user_id);

-- Aggregated stats: users select only their own
drop policy if exists "user_stats_select_own" on public.user_stats;
create policy "user_stats_select_own"
on public.user_stats
for select
using (auth.uid() = user_id);

-- (Optional) allow users to delete their own scores
-- drop policy if exists "scores_delete_own" on public.scores;
-- create policy "scores_delete_own"
-- on public.scores
-- for delete
-- using (auth.uid() = user_id);

-- 4) Seed template (needs real auth.users UUIDs)
-- IMPORTANT:
-- - Because `profiles.id` and `scores.user_id` reference `auth.users(id)`,
--   you MUST create users first (Google sign-in or email) then copy their UUIDs.
--
-- Example:
-- insert into public.profiles (id, username)
-- values
--   ('REPLACE_WITH_REAL_AUTH_USER_UUID_1', 'DemoPlayer1'),
--   ('REPLACE_WITH_REAL_AUTH_USER_UUID_2', 'DemoPlayer2')
-- on conflict (id) do update set username = excluded.username;
--
-- insert into public.scores (user_id, username, score)
-- values
--   ('REPLACE_WITH_REAL_AUTH_USER_UUID_1', 'DemoPlayer1', 120),
--   ('REPLACE_WITH_REAL_AUTH_USER_UUID_2', 'DemoPlayer2', 95);
